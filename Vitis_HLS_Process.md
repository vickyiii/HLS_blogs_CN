
# Vitis HLS Process Overview
Vitis HLS 基于工程，可包含多个solution（称为“解决方案”）以驱动综合与仿真。每个解决方案均可将 Vivado IP 流程或 Vitis kernel流程设定为目标。基于目标流程，每个解决方案都将指定不同的约束和最优化指令，如 启用 [Vivado IP Flow](https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/Interfaces-for-Vivado-IP-Flow) 和 启用 [Vitis Kernel Flow](https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/Interfaces-for-Vitis-Kernel-Flow) 中所述。如需获取两个流程之间的差异的清晰列表，请参阅 Vivado/Vitis 流程的默认设置。

以下提供了典型设计流程中的综合、分析与最优化步骤：

1. 创建新的 Vitis HLS 工程。
1. 利用 C 语言仿真来验证源代码。
1. 运行高层次综合以生成 RTL 文件。
1. 分析结果，包括检验时延、启动时间间隔 (II)、吞吐量和资源使用情况。
1. 执行最优化，并按需重复此步骤。
1. 使用 C/RTL 协同仿真验证结果。

Vitis HLS 基于目标流程、默认工具配置、设计约束和我们指定的任意最优化编译指示或指令来实现解决方案。我们可使用最优化指令来修改和控制内部逻辑和 I/O 端口的实现，以覆盖工具的默认行为。

### C/C++ 代码综合方式如下：

- 顶层函数实参由 Vitis HLS 自动综合到 RTL I/O 端口接口内。如[定义接口](https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/Defining-Interfaces)中所述，该工具创建的默认接口取决于目标流程、函数实参的数据类型和方向、默认接口模式以及用户指定的任何 INTERFACE 编译指示或指令（用于手动定义接口）。

- 顶层 C/C++ 函数的子函数综合到 RTL 设计的层级内的各块中。
    - 最终 RTL 设计包含与原始顶层 C 语言函数层级相对应的模块或实体层级。
    - Vitis HLS 会将子函数根据需要自动内联到更高层次的函数中或者内联到顶层函数中，以提升性能。
    - 我们可通过在解决方案中向子函数指定 INLINE 编译指示，或者使用 set_directive_inline 并将其设置为 OFF 来禁用自动内联。
    - 默认情况下，C 语言子函数的每次调用使用的 RTL 模块的实例是相同的。但我们可以通过在解决方案中指定 ALLOCATION 编译指示或者使用 set_directive_allocation 来实现多个 RTL 模块实例以提升性能。
- 默认情况下，C 语言函数中的循环将保持收起状态，并采用流水打拍以提升性能。
    - Vitis HLS 工具将不会展开循环，除非这样能够提升解决方案性能，如展开嵌套的循环以对顶层函数进行流水打拍。收起循环时，综合会为循环的单次迭代创建逻辑，RTL 设计会为序列中循环的每次迭代都执行此逻辑。展开循环允许循环的部分或全部迭代并行发生，但也会耗用更多器件资源。
    - 我们可以使用 UNROLL 编译指示或 set_directive_unroll 命令来手动展开循环。
    - 循环还可通过如下任一方法进行流水打拍：通过有限状态机高精度实现（循环流水打拍）或者采用基于较低精度的握手的实现（数据流）。
- 代码中的阵列将综合到最终 FPGA 设计中的块 RAM (BRAM)、LUT RAM 或 UltraRAM 中。
    - 如果阵列位于顶层函数接口上，那么高层次综合可将此阵列作为端口来实现，以便访问设计外部的块 RAM。
    - 我们可使用 ARRAY_PARTITION 或 ARRAY_RESHAPE 编译指示或者关联的 set_directive_array 命令更改默认分配，以便重新配置使用的存储器类型或者重新配置读/写存储器传输。
 
 **Important:** 在 Vitis HLS 中，如果在特定范围（函数/循环/区域）内指定编译指示或指令，那么该工具的默认行为将被我们的编译指示所覆盖，如上所述。在此类情况下，如果在当前范围内已指定编译指示或配置，则无法应用默认功能特性，如含低迭代计数的循环自动流水打拍。

综合后，我们可以对先前生成的各项报告中的结果进行分析，以确定结果质量。分析结果后，我们可以为工程创建其它解决方案，指定不同的约束和最优化指令，并对这些结果进行综合与分析。我们可对不同解决方案的结果进行比较，查看哪些有效，哪些无效。我们可重复此过程，直至设计达成所期望的性能特性为止。我们可使用多种解决方案持续进行开发，同时仍可保留先前的解决方案。